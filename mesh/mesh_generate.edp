load "medit"
//メッシュ作成用のプログラム
int Diriclet=2,Neumann=2;

int sepD=150;
int sepN=sepD;
int sep=20;

real a=0.0,b=0.0;

real sta=-pi;
real rho=1.0;
real fin=sta+2*pi;

border CC1(t=sta,fin){x=cos(t)+a;y=sin(t)+b;label=Neumann;};
// border CC(t=(1-rho)*pi,(1+rho)*pi){x=cos(t)+a;y=sin(t)+b;label=Diriclet;};
// border CC2(t=(1-rho)*pi,fin){x=cos(t)+a;y=sin(t)+b;label=Neumann;};
mesh Th=buildmesh(CC1(sepN));

border b1(t=0,1){x=t;y=0;label=Diriclet;};
border b2(t=0,1){x=1;y=t;label=Neumann;};
border b3(t=0,1){x=1-t;y=1;label=Diriclet;};
border b4(t=0,1){x=0;y=1-t;label=Neumann;};
// mesh Th=buildmesh(b1(sep)+b2(sep)+b3(sep)+b4(sep));

savemesh(Th,"mesh01.msh");
medit("mesh01.msh",Th,wait=true);
// fespace Vh(Th,P1);

// func f=1.0;

// Vh u,v;
// problem poisson(u,v)=
//     int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v))+
//     int2d(Th)(f*v);

// poisson;
// plot(u,dim=3,fill=true,grey=true);
// for(int i=0;i<Th.nv;i++){
//     cout<<"i="<<i+1<<","<<u(Th(i).x,Th(i).y)<<endl;
// }


// varf a(u,v)=int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v));
// matrix A(Vh,Vh);
// varf b(u,v)=int2d(Th)(f*v);