//メッシュ作成用のプログラム
int Diriclet=1,Neumann=2;

int sepD=50;
int sepN=sepD;

border CC1(t=0,pi){x=cos(t);y=sin(t);label=Diriclet;};
border CC2(t=pi,2*pi){x=cos(t);y=sin(t);label=Neumann;};
mesh Th=buildmesh(CC1(sepD)+CC2(sepN));//

border b1(t=0,1){x=t;y=0;label=Diriclet;};
border b2(t=0,1){x=1;y=t;label=Neumann;};
border b3(t=0,1){x=1-t;y=1;label=Diriclet;};
border b4(t=0,1){x=0;y=1-t;label=Neumann;};
// mesh Th=buildmesh(b1(sep)+b2(sep)+b3(sep)+b4(sep));

savemesh(Th,"mesh01.msh");
plot(Th,wait=0);
fespace Vh(Th,P1);

real D=0.5,dt = 0.01,alpha=1./dt,t;

func real f(real t){
  return 2*t*(1-x^2-y^2) + 4*D*(1+t^2);
}
func real ue(real t){
  return (1-x^2-y^2)*(1+t^2);
}

Vh u,v,uold,uexact,eh;
real E0=0.0,E1=0.0,E0denom,E1denom,tmp;
int i=0;

problem heat(u,v, solver=Crout, init=i)=
  int2d(Th)( alpha*u*v + D*( dx(u)*dx(v)+dy(u)*dy(v) ) ) - int2d(Th)(alpha*uold*v) - int2d(Th)(f(t)*v)
  +on(Diriclet,Neumann,u=0.0);

u = 1.-x^2-y^2;
plot(u,dim=3,fill=true,wait=0);

for(int i=1;i<=100;i++){
  uold = u;
  t=i*dt;
  heat;

  uexact = ue(t);
  plot(u,     dim=3,fill=true,wait=0, value=true,cmm="uh,     t="+t);
  plot(uexact,dim=3,fill=true,wait=0, value=true,cmm="uexact, t="+t);

  eh = u-uexact;
  tmp = int2d(Th)( eh*eh );                       tmp = sqrt(tmp); if(E0<tmp) E0=tmp;
  tmp = int2d(Th)( dx(eh)*dx(eh)+dy(eh)*dy(eh) ); tmp = sqrt(tmp); if(E1<tmp) E1=tmp;
  tmp = int2d(Th)( uexact*uexact );                               tmp = sqrt(tmp); if(E0denom<tmp) E0denom=tmp;
  tmp = int2d(Th)( dx(uexact)*dx(uexact)+dy(uexact)*dy(uexact) ); tmp = sqrt(tmp); if(E1denom<tmp) E1denom=tmp;
  cout << "t = " << t << ", E0 = " << E0 << endl;
  cout << "t = " << t << ", E1 = " << E1 << endl << endl;
}

cout << "Relative error in Linf(L2)-norm:  " <<  E0/E0denom << ", (E0, E0denom) = (" << E0 << ", " << E0denom << ")" << endl;
cout << "Relative error in Linf(H10)-norm: " <<  E1/E1denom << ", (E0, E0denom) = (" << E1 << ", " << E1denom << ")" << endl;

